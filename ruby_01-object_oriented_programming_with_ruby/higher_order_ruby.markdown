## Higher Order Ruby -- Programming with Blocks, Procs, and Lambdas

### Learning Goals

* Develop a mental model for what happens when we use a "block" in ruby
* Understand how to create new Proc and Lambda objects
* Understand how to call a Proc or Lambda
* Understand how to accept a block passed to your method and invoke it using `yield` and using the `&block` syntax
* Take a first sip from the cup of functional programming arcana

### Warmup

Write a bit of ruby code to do the following:

1. Take the names of the 2 people sitting next to you
2. Generate a new list of those names where all of the vowels are removed
3. Write this once using an enumerable and once without (use for, a loop, etc)

When you finish, take a few minutes to think about what the differences between these 2 pieces of code.

### Discussion -- Blocks, Procs, Lambdas -- OH MY

Discussion/Questions:

* In what context have you used Blocks in ruby code?
* What does a Block represent?
* Give 3 code snippets using a block
* What would these snippets look like __without__ a block?

### Terminology -- Blocks vs. Procs/Lambdas

* blocks -- _technically_ a block is just part of the language's syntax
* a "Block" is really just a block of code -- a syntactically contained segment of source code
* "blocks" appear in other languages (Java, Javascript, etc) just as they do in ruby -- to indicate a self-contained chunk of code. The `{ }` notation is very common for this, and you'll see it in Java, JS, C, etc.
* Ruby borrows this notation, but also adds its own touch with the `do` / `end` variation
* [Example JS Reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block)

#### Technical Terminology vs. Common Usage

* However generally when people talk about "blocks" in ruby, they're actually talking about what happens when you pass
a block to a method
* Remember -- a _block_ is technically just the textual indication that some chunk of code should stand on its own
* But what actually happens under the hood with the text that we are passing in?
* Consider a similar example: we often say "Array" to mean the syntactic convention of surrounding a list of comma-separated elements by square brackets (`[1,2,3,4]`)
* But *technically* `Array` is the thing (an Object) that ruby creates for us automatically when we type `[1,2,3,4]`
* So what **Object** does ruby make for us when we type a **Block** of code surrounded by either `{ }` or `do` / `end`?
* Turns out this object is a `Proc` -- `Proc` is the Ruby class which represents the idea of "a chunk of code saved for later use"

### So what actually happens when we pass a block to a method?

Rules:

1. Ruby allows a Block to be passed to any method as an optional final argument
2. It's up to the methods implementation to determine how (or even if) to use the provided block

**Exercise**

1. Define a method `print_name(name)` which takes a name as an argument and prints it
2. Call that method using your name
3. Call that name using your name _AND_ a block of your choosing

What happened to the block you provided? Why does ruby not complain when you pass the block even though it's not being used? (**Hint:** see rules 1 and 2 above)

### Using a block passed to your method

There are 2 ways to do this

#### 1. `yield` and `block_given?` methods

**Exercise -- yielding from a method**

Revisit your `print_name`. From inside the method, add a line that simply calls the method `yield`. It may look something like this:

```ruby
def print_name(name)
  puts "HI, #{name}"
  yield
end
```

**Exercise**

Now try your 2 examples from before:

1. Call this version of `print_name` with a block
2. Call this version without passing a block

Which works, which doesnt?

**`block_given?`**

Special method that lets us check if a block was actually provided to avoid LocalJumpErrors

#### 2. Explicit argument capturing using the `&` operator

We can also explicitly "capture" the block parameter:

```ruby
def print_name(name, &block)
  puts "HI, #{name}"
  puts block.class
end
```

### Proc by any other name

In the previous example, what did we see? What object did ruby turn our "block" into?

* `Proc` -- ruby's class for representing stored collections fo ruby instructions -- i.e. the output that is actually generated by a block
* Term `proc` comes from _proc_edure
* Tries to capture the idea of a proc as an actual process that is stored for later
* Other languages use other terms -- function, lambda, routine, functor
* rubyists _create_ and pass blocks all the time -- e.g. every time you use an enumerable
* but not many people actually write code that _accepts_ blocks
* even though ruby has great support for this type of programming (and it can be used to do powerful things) it's not a very common part of the languages style

### Invoking a Proc

If a proc represents the idea of a stored "procedure", we need some way to "un-store" it -- i.e. to evalate it

3 ways:

1. `Proc#call`
2. `Proc.()`
3. `Proc[]`

**Exercise**

__First__, define a simple proc in pry:

```ruby
my_proc = Proc.new { |i| puts "you provided i: #{i}" }
```

__Second__, use the 3 methods described above to "invoke" the proc with an argument

__Third__, revisit our example from above and use these techniques on the `block` variable that we captured as part of our method:

```ruby
def print_name(name, &block_that_was_passed_in)
  puts "HI, #{name}"
  # Use one of the 3 Proc methods to call the block here
end
```

**Note** In practice, `Proc#call` is probably the most common of these.

### Scope, local variables, and closures

* Recall how we describe an object: a collection of behavior combined with labels
* Procs have some similarities -- they bind a chunk of code to a collection of local variables; we call this collection of variables a "lexical context"

Block scope example. Ever wonder why this works?

```ruby
x = 5

def method_cant_see_surrounding_local_vars
  puts x
end

5.times do
  puts "but procs can #{x}"
end
```

So where does a block's lexical context come from?

* bindings -- objects' way of tracking local variable context
* when we create a new block, it takes on the binding of the context in which it was created.
* this lets a block share (and update -- more on that in a second) the local variables that were defined in the context _in which it was created_.
* This behavior is what we describe as a _closure_ -- we say the block "closes over" the local variables, allowing it to take them with it
* Closures are portable just like procs -- even if we pass the proc off to another method or place in code, it maintains its ability to access those local variables that were defined in the context that created it.

### Higher-Order Functions

* Term in programming for functions (methods) that take other methods as arguments
* design pattern -- allows us to generalize a common process in a way that users (other programmers) can very flexibly customize it to fit their various problems

For example `map` -- this method represents the _idea_ of using some process (the block) to transform a collection of values into a new collection

We could hard code this in the standard way:

```ruby
nums = [1,2,3,4]
i = 0
doubles = []
while i < nums.length
  doubles << nums[i] * 2
  i += 1
end

doubles
=> [2,4,6,8]
```

What could be improved about this code?

The pieces are rigidly connected together

### Exercises

#### 1. Each with a proc

Write your own each method which takes 2 arguments: an array and a proc. Execute the proc for each element in the array using `call`. For example:

```ruby
def my_each(array &block)
  #stuff
end
```

Make sure your each method returns the original collection when it's done

#### 2. Map with a proc

Do the same as above but this time for map

```ruby
def my_each(array &block)
  #stuff
end
```

Make sure your map method returns the collection of new values when it's done

#### 3. :fire: :fire: Spicy -- Write a Partial Application method

Functional programming is a programming paradigm that focuses on, among other things, the idiomatic manipulation of functions as values. Functional programming languages generally include a primitive type for representing a function as a value, and the `Proc` is Ruby's version of this.

Once common technique in FP languages is to take a function that accepts `N` arguments and "partially" evaluate it to generate a new function which takes `N - 1` arguments.

For example in Clojure we might see:

```clojure
;; add things
cljs.user=> (+ 1 1)
2
;; add multiple things -- note that the "+" function takes any number of arguments
cljs.user=> (+ 1 2 3 4)
10
;; partially evaluate the + function to generate a new function, plus-five
cljs.user=> (def plus-five (partial + 5))
;; add 5 to something
cljs.user=> (plus-five 6)
11
```

Can you achieve the same thing in ruby? I bet you can! See if you can write your own method, `partial`, which takes a Proc and an argument and generates a new Proc which works like the original one but _with the first argument already applied_.

For example:

```ruby
add_nums = Proc.new { |a, b| a + b }
add_nums.call(1,2) # => 3

def partial(proc, arg)
  # stuff
end

add_five = partial(add_nums, 5)

add_five.call(2) # => 7
```

### Appendix: Procs vs Lambdas

* lambdas basically a subtype of proc
* only 2 differences

1. Lambdas are strict about their number of arguments (fancy CS word -- arity)
2. `return` keyword -- in a lambda this will return only from the local context i.e the block itself; in a proc this will return from the surrounding method context
